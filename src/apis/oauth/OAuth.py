import logging
from pydantic import BaseModel, Field, model_validator
from time import time


from src.apis.general.Api import ApiFetcher


# Known keys to find token data
OAUTH_ACCESS_TOKEN_KEY = 'access_token'
OAUTH_TOKEN_EXPIRE_KEY = 'expires_in'


logger = logging.getLogger(__name__)


class OAuthApi(BaseModel):
    """
    :param name: Optional custom name for the API.
    :param token_request: ApiFetcher object that contains the request to get the token
    :param data_request: ApiFetcher object that contains the request to get the data
    :param scrape_interval_minutes: the interval between scraping jobs.
    :param token: The access token, generated by the class after the first request call.
    :param token_expire: The access token expiration time in UNIX, generated by the class after the first request call.
    """
    name: str = Field(default="oauth")
    token_request: ApiFetcher
    data_request: ApiFetcher
    scrape_interval_minutes: int = Field(default=1, alias="scrape_interval", ge=1)
    additional_fields: dict = Field(default={})
    token: str = Field(default=None, init=False, init_var=True)
    token_expire: float = Field(default=0, init=False, init_var=True)

    @model_validator(mode='after')
    def _check_headers(self):
        """
        Validates that:
        - Data request has 'Content-Type' header as 'application/json'
        :return: self
        """
        # Make sure the content-type exists for the data request
        if not self.data_request.headers.get("Content-Type"):
            self.data_request.headers["Content-Type"] = "application/json"

        # Initialize the type
        if not self.additional_fields.get("type"):
            self.additional_fields["type"] = "api-fetcher"

        return self

    def _token_expired(self):
        """
        Returns if the token expiration time passed.
        :return: true if token is expired, false otherwise
        """
        return time() > (self.token_expire - 60)

    def _update_token(self):
        """
        Checks if the token expiration passed and if so, gets a new one and updates the data request 'Authorization'
        header accordingly.
        """
        token_response = {}

        if self._token_expired():
            try:
                logger.debug("Sending request to update the access token.")
                token_response = self.token_request.send_request()[0]
                self.token, self.token_expire = (token_response.get(OAUTH_ACCESS_TOKEN_KEY),
                                                 int(token_response.get(OAUTH_TOKEN_EXPIRE_KEY)) + time())
                self.data_request.headers["Authorization"] = f"Bearer {self.token}"
            except IndexError:
                logger.error("Failed to get token for OAuth API request.")
            except ValueError:
                logger.error(f"Failed to get token expiration time. Received value "
                             f"'{token_response.get(OAUTH_TOKEN_EXPIRE_KEY)}'.")

    def send_request(self):
        """
        Makes sure the token expiration is not passed and sends a request to get data.
        :return: all the responses that were received from the data request
        """
        logger.debug("Checking if to update the access token and sending request to get data.")
        self._update_token()
        return self.data_request.send_request()
