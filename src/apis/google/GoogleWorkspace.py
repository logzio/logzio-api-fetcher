import logging
import re
from datetime import datetime, timedelta, UTC

from google.auth.credentials import TokenState
from google.auth.exceptions import MalformedError
from google.auth.transport.requests import Request
from google.oauth2 import service_account
from pydantic import Field, ConfigDict, model_validator

from src.apis.general.Api import ApiFetcher
from src.apis.general.PaginationSettings import PaginationSettings
from src.apis.general.StopPaginationSettings import StopPaginationSettings, StopCondition
from src.apis.oauth.OAuth import OAuthApi

DEFAULT_ENCODING = "utf-8"
FETCHER_PATH = "./src/shared/"
DATE_FILTER_PARAMETER="startTime="
FIND_DATE_PATTERN = re.compile(r'startTime=(\S+?)(?:&|$)')
DATE_FORMAT = "%Y-%m-%dT%H:%M:%S.%fZ"

logger = logging.getLogger(__name__)


class GoogleWorkspace(OAuthApi):
    """
    :param google_ws_sa_file_name: Optional if file path wasn't configured, name of the service account file.
    :param google_ws_sa_file_path: Optional if file name wasn't configured, path to the service account file.
    :param google_ws_delegated_account: email of the user for which the application is requesting delegated access.
    :param scopes: list of scopes for the API.
    :param days_back_fetch: The amount of days to fetch back in the first request
    :param creds: Not passed to the class, credentials generated by the class.
    """
    model_config = ConfigDict(arbitrary_types_allowed=True)
    google_ws_sa_file_name: str = Field(default="", frozen=True)
    google_ws_sa_file_path: str = Field(default=None)
    google_ws_delegated_account: str = Field(frozen=True)
    scopes: list = Field(default=["https://www.googleapis.com/auth/admin.reports.audit.readonly"], frozen=True)
    days_back_fetch: int = Field(default=1, frozen=True, ge=1)
    creds: service_account.Credentials = Field(default=None)

    def __init__(self, **data):
        # token request for Google is dummy due to the use of Google library to avoid manual JWT generation.
        token_req = ApiFetcher(url="dummy")
        data_req = ApiFetcher(
            **data.pop("data_request"),
            pagination=PaginationSettings(
                type="url",
                update_first_url=True,
                url_format="&pageToken={res.nextPageToken}",
                stop_indication=StopPaginationSettings(field="nextPageToken",
                                                       condition=StopCondition.EMPTY)),
            response_data_path=data.pop("response_data_path", "items")
        )
        super().__init__(token_request=token_req, data_request=data_req, name=data.pop("name", "Google Workspace"), **data)
        self._initialize_url_date()
        if self. google_ws_sa_file_path is None:
            self.google_ws_sa_file_path = FETCHER_PATH + self.google_ws_sa_file_name

    @classmethod
    @model_validator(mode='before')
    def _check_path(cls, data):
        if data.get("google_ws_sa_file_name") is None and data.get("google_ws_sa_file_path") is None:
            raise ValueError("One of google_ws_sa_file_name, google_ws_sa_file_path must be set!")
        return data

    def _initialize_url_date(self):
        self.data_request.url += ("&" if "?" in self.data_request.url else "?") + f"startTime={self._generate_start_fetch_date()}"

    def _generate_start_fetch_date(self):
        return (datetime.now(UTC) - timedelta(days=self.days_back_fetch)).isoformat().replace("+00:00", "Z")

    def _token_expired(self):
        """
        Override OAuth method due to use of special google library to avoid manual generating JWT.
        :return: true if token is expired, false otherwise
        """
        if self.creds is None:
            return True
        return not self.creds.token_state == TokenState.FRESH

    def _update_token(self):
        """
        Override OAuth method due to use of special google library to avoid manual generating JWT.
        """
        if self._token_expired():
            try:
                logger.debug("Sending request to update the access token.")
                self.token, self.token_expire = self._generate_creds()
                self.data_request.headers["Authorization"] = f"Bearer {self.token}"
            except FileNotFoundError:
                logger.error(f"Did not find file {self.google_ws_sa_file_path}.")
            except MalformedError as e:
                logger.error(f"Malformed Service Account credentials file: {e}.")
            except Exception as e:
                logger.error("Failed to generate google access token for OAuth API request due to error: ", e)

    def _generate_creds(self):
        """
        Generates credentials for the Google API.
        :return: the OAuth token and the expiration time.
        """
        self.creds = service_account.Credentials.from_service_account_file(self.google_ws_sa_file_path, scopes=self.scopes)
        self.creds = self.creds.with_subject(self.google_ws_delegated_account)
        self.creds.refresh(Request())
        return self.creds.token, self.creds.expiry

    def send_request(self):
        """
        1. Sends request using the super class
        2. Add 1 second to the date from the end of the URL to avoid duplicates in the next call
        :return: all the responses that were received
        """
        data = super().send_request()

        # Add 1s to the time we took from the response to avoid duplicates
        if DATE_FILTER_PARAMETER in self.data_request.url:
            self.data_request.add_seconds_to_url_date_filter(1, DATE_FORMAT, FIND_DATE_PATTERN)

        return data